package interview.fourth_book.basic;

import org.junit.Test;

/**
 * @author chensy
 * @date 2023/7/12
 */
public class BitOperationTest { //@MsY-Doing

    /**
     * 知识点：位运算
     *
     * 知识点概要：
     * 1）移位运算：
     *    1.1）左移操作符<< ：将数据转换成二进制数后，向左移若干位，高位丢弃，低位补零
     *    1.2）右移操作符>> ：将数据转换成二进制数后，向右移若干位，高位补符号位，低位丢弃
     *
     * 关联点学习：
     * 1）移位运算的相关规则学习：如左移<<、右移>>、无符号移动等（Doing）
     * 2）按位运算的相关规则学习：如按位与、按位异或等（Doing）
     * 3）补码、反码等相关规则学习（Doing）
     *
     * 问题点答疑：
     * 1）移位运算的好处以及应用场景是怎样的？
     * 2）按位运算的好处以及应用场景是怎样的？
     *
     * 参考链接：
     * a）https://juejin.cn/post/6844904025880526861 Java的移位运算符
     */

    /**
     * 场景1：左移运算
     */
    @Test
    public void test_left_move() { //Done
        int a = 3;
        System.out.println(a << 4);

        /**
         * 输出结果：
         * 48
         *
         * 结果分析：
         * 将3转换为2进制表示，因为一个int占4个字节，一个字节8位
         * 1）3对应的二进制数为：00000000000000000000000000000011
         * 2）3左移4位的二进制数为：00000000000000000000000000110000 (即对应的10进制数为48)
         */
    }

    /**
     * 场景2：打印int的二进制形式
     */
    @Test
    public void test_print() { //Doing
        int num = 48;
        for(int i = 31; i >= 0; i--) {
            System.out.print((num & 1 << i) == 0 ? "0":"1");
        }

        /**
         * 输出结果：
         * 00000000000000000000000000110000
         *
         * 结果分析：
         * 1）int类型占4个字节，一个字节8位，int共占32位。java中的int是无符号的
         *   （c语言还区分int整形和unsigned int无符号整型），取值范围 -2^31~2^31-1。
         * 2）二进制数在内存中以补码的形式存储的
         *   正数：补码就是转化为二进制
         *   负数：补码符号位是1，其它位是对应正数的二进制的取反加一
         *
         * 问题点答疑：
         * 1）num & 1 << i 运算的功能用途是什么？
         */
    }

    /**
     * 场景2：按位或
     *
     * 验证：(srcIdx | srcSize | srcBytes.length - srcIdx - srcSize) < 0 只要有一个位负数就为负数
     */
    @Test
    public void test_bitwise_opt() { //Doing

        int a = 10, b = 9;
        System.out.println("a & b = " + (a & b));
        System.out.println("a | b = " + (a | b));

        /**
         * 输出结果：
         * a & b = 8
         * a | b = 11
         *
         * 结果分析：
         * 1）二进制表示（除二取余：方便起见，以1个字节8位表示，严格的话，应该按4个字节32位表示）
         *   a的二进制形式：00001010
         *   b的二进制形式：00001001
         *   a & b =     00001000 => 8
         *   a | b =     00001011 => 11
         *
         * 2）按 "逻辑运算"规则来推导 "按位运算"规则，(因为0，1有4种组合，记住同为1和同为0的情况，其它情况就好记了)
         *    把真假看为1和0，逻辑运算中：&& =》两个都为真即为真，所以推导 & =》两个位都为1，即为1
         *    || =》两个都为假，即为假，所以推导 | =》两个为都为0，即为0
         *
         * 问题点答疑：
         * 1）等比数列的求和公式是怎样的？如 2^0 + 2^1 ... + 2^7
         * 2）除二取余法，具体是怎样的规则？还有别的方式获取二进制形式吗？
         */
    }


    /**
     * 场景3：特定运算的结果
     */
    @Test
    public void test_special_opt() { //Done
        int a = 1 << 13;
        System.out.println(a);

        int b = 32 >> 3;
        System.out.println(b);

        /**
         * 输出结果：
         * 8192
         * 4
         *
         * 结果分析：
         * 1）左高右低，往做移动一位就*2，移动13位，就是2^13次方
         * 2）左移后，低位补0，左移1位，值乘以2；右移后，高位补零，右移1位，值除以2
         */
    }

}
